<% render("docUtils.eRender",{
Title = "BaseLib";
Body = [[
The Valkyrie wrapper is controlled by a part of the core called BaseLib. The
wrapper object has a few methods and properties which can be used to control how
it behaves.
]];
Properties = {
	{
		Name = "fixTables";
		Type = "bool";
		Default = false;
		Body = [[
If enabled, forces all function arguments back through the wrapper to make sure
that all changes are captured incase metamethods are missed due to how Lua
tables work.

Enabling this can have serious performance implications in functions which take
big tables, deep tables or large amounts of functions as all elements must be
passed through the wrapper recursively.
		]];
		Meta = "Slow";
	};
 	{
 		Name = "useStackedWrappers";
 		Type = "bool";
 		Default = false;
 		Body = [[
`useStackedWrappers` is an experimental setting property for the Valkyrie wrapper
object which tells the wrapper to wrap objects that are already wrapped. This
can cause instability when enabled and is disabled by default for a reason.

Wrapper stacking should only be enabled if you know what you're doing and you
need integrity across multiple levels of user code. (Sandboxes)
 		]];
 		Meta = "Experimental";
 	};
 	{
 		Name = "useFullConversion";
 		Type = "bool";
 		Default = false;
 		Body = [[
If `useFullConversion` is enabled, the wrapper will attempt to unwrap any userdata
objects which try to be unwrapped even if they're not wrapped.

By default, the wrapper doesn't unwrap userdata if it's not already wrapped and
doesn't have an unwrap target.
 		]];
 	};
 	{
 		Name = "convertFullBidirectional";
 		Type = "bool";
 		Default = true;
 		Body = [[
If enabled, the wrapper will try to unwrap anything that needs unwrapping, even
if it isn't wrapped. This allows functions and tables made inside a wrapped env
function reliably outside of a wrapped environment. Only disable for applications
using manual wrapper conversion.
 		]];
 	};
 	{
 		Name = "useContextInversion";
 		Type = "bool";
 		Default = true;
 		Body = [[
If enabled, the wrapper will not unwrap anything that has a wrap target and no
unwrap target. This pairs with `useStackedWrappers` and `useFullConversion`, and if
you are changing `useContextInversion`, you should also change `useStackedWrappers`
and `useFullConversion`.
 		]];
 	};
 	{
 		Name = "genSeed";
 		Type = "number";
 		Default = "tick()";
 		Body = [[
A unique identifier for the wrapper. Doesn't actually do anything at the moment
and is unlikely to do anything in the near future. Behaves as the identifier in
the wrapper's `__tostring` metamethod.
		]];
		Meta = "Unused";
	};
	{
		Name = "TypeIdentities";
		Type = "table";
		Default = "_G.TypeIdentities or {}";
		Body = [[
Stores unique type identifiers for objects. Should be used by developers that
want their objects to be Valkyrie compatible.
		]];
	};
	{
		Name = "TypeChecks";
		Type = "table";
		Default = "{Vector3 = function(...),...}";
		Body = [[
Stores `pcall`-able functions used to systematically check the internal type of
userdata objects such as Vector3, Color3, UDim2, etc.
		]];
	};
	{
		Name = "mt";
		Type = "table";
		Default = "{__index = function(...),...}";
		Body = [[
Contains the default metamethods applied to all applicable datatypes. All
metamethods are wrapped AoT.
		]];
	};
	{
		Name = "imt";
		Type = "table";
		Default = "{__index = function(...),...}";
		Body = [[
Contains all of the metamethod overrides for Instances.
		]];
	};
	{
		Name = "umt";
		Type = "table";
		Default = "{}";
		Body = [[
Contains all metamethod overrides for identifiable types from `TypeIdentities`.
		]];
	};
	{
		Name = "inversemt";
		Type = "table";
		Default = "{__index = function(...),...}";
		Body = [[
Contains the default metamethods applied to all applicable datatypes. Exactly
the same as mt, but the wrapping order is inverted.

This is only used internally as it should have no manual application other than
to change metamethods universally alongside `mt`
		]];
	};
	{
		Name = "ulist";
		Type = "table";
		Default = "{}";
		Body = [[
Contains all of the unwrap targets for objects. unwrap [k] -> v
		]];
		Aliases = {"unwrapper"};
	};
	{
		Name = "wlist";
		Type = "table";
		Default = "{}";
		Body = [[
Contains all of the wrap targets for objects. wrap [k] -> v
		]];
		Aliases = {"wrapper"};
	};
	{
		Name = "Overrides";
		Type = "table";
		Default = "{Globals = {}; Instance = {}; Types = {}}";
		Body = [[
Contains all of the overrides from the override methods. The Globals table is a
simple table used by LoadLibrary's injector as an `__index` fallback, the Instance
table is a table of added methods by class, and the Types table is a table of
metamethod overrides by class.
		]];
	};
};
Methods = {
	{
		Name = "wrap";
		Arguments = {
		{
			Name = "Value";
			Type = "var";
		};
		};
		Returns = {
		{
			Name = "WrappedValue";
			Type = "var";
		};
		};
		Body = "Wraps the supplied value";
	};
	{
		Name = "unwrap";
		Arguments = {
		{
			Name = "Value";
			Type = "var";
		};
		};
		Returns = {
		{
			Name = "WrappedValue";
			Type = "var";
		};
		};
		Body = "Unwraps the supplied value";
	};
	{
		Name = "mod";
		Arguments = {
		{
			Name = "From";
			Type = "var";
		};
		{
			Name = "To";
			Type = "var";
			Nullable = true;
		};
		};
		Body = [[
When ever the wrapper encounters the object in `From`, it will replace it with the
object in `To`
		]];
	};
	{
		Name = "Override";
		Arguments = {
		{
			Name = "Type";
			Type = "string";
		};
		};
		Returns = {
		{
			Name = "ChainTable";
			Type = "table";
			Meta = {
				__call = {
					Type = 'function';
					Meta = {
						Arguments = {
						{
							Name = "Overrides";
							Type = "table";
						};
						};
					};
				};
				Instance = {
					Type = 'function';
					Meta = {
						Arguments = {
						{
							Name = "this";
							Type = "self";
						};
						{
							Name = "Overrides";
							Type = "table";
						};
						};
					};
				};
			};
		}
		};
		Body = [[
		Overrides either an Instance class or some other userdata type. Whether
		the type can be overridden depends on whether the type has a checking
		function to identify it.

		If overriding an Instance class, the `:Instance` method must be used.
		]];
	};
	{
		Name = "OverrideGlobal";
		Arguments = {
		{
			Name = "GlobalName";
			Type = "string";
		};
		};
		Returns = {
		{
			Name = "ChainFunction";
			Type = "function";
			Meta = {
				Arguments = {
				{
					Name = "Overrides";
					Type = "table";
				};
				};
			};
		};
		};
		Body = [[
		Allows you to override a global variable, such as `game` or `Color3` and
		insert your own members. It tries to be as non-destructive as possible,
		allowing multiple libraries to modify the same things, however in some
		cases this simply isn't possible and the library which was loaded last
		will take precedence in its modifications.
		]];
	};
	{
		Name = "GenExt";
		Meta = "Experimental";
		Arguments = {
		{
			Name = "ExtFunction";
			Type = "function";
			Meta = {
			Returns = {
			{
				Name = "...";
				Type = 'var';
			};
			};
			};
		};
		};
		Returns = {
		{
			Name = "InvertedFunction";
			Type = "function";
			Meta = {
			Returns = {
			{
				Name = "...";
				Type = 'var';
			};
			};
			};
		};
		};
		Body = [[
		Generates an inverted version of the function, which has wrapped arguments
		and unwrapped returns. This is used already by the wrapper to try and solve
		most issues, but some functions may need explicit wrapping to solve any
		mismatches between the function wrapper environment and the argument
		wrapper environment.
		]];
	};
	{
		Name = "_rawConvert";
		Meta = "Experimental";
		Arguments = {
		{
			Name = "FromEnvironment";
			Type = "table";
		};
		{
			Name = "ToEnvironment";
			Type = "table";
		};
		{
			Name = "this";
			Type = "VlkyrWrapper";
		};
		{
			Name = "ConversionTarget";
			Type = "var";
		};
		};
		Return = {
		{
			Name = "ConvertedReturn";
			Type = "var";
		};
		};
		Body = [[
		This is the raw conversion function used internally to wrap and unwrap
		objects. It can be used to implement your own wrappers, or even to
		make a sandbox with some very tricky context conversion.

		It is not advised to use this manually unless you know exactly what you
		are doing, as it is better practice to use the provided `wrap` and `unwrap`
		functions.
		]];
	};
};
}) %>